{"name":"Learnvolleysorcecodenote","tagline":"Volley源码学习","body":"1.设计图\r\n（StringRequest  JSonRequest ImageRequest） 构成 RequestQueue\r\n=>\r\n(CacheDispatcher NetworkDispatcher)  构成 Dispatch Thread\r\n=>\r\n(Cache HttpClientStack HurlStack) 构成 Get Data Interface\r\n=>\r\n(Memory和File System    Server) 构成Server\r\n\r\n2.Volley中的概念\r\n 1) Volley：对外暴露的API，通过newRequeueQueue新建并启动一个队列RequestQueue后，然后加入add和Request。\r\n 2）Request 抽象类 用于请求。子类有StringRequest，JsonRequest,ImageRequest\r\n 3）RequestQueue：请求队列，包含CacheDispatcher（缓存的调度线程），NetWorkDispatcher（网络请求调度线程），ResponseDelivery(返回结果分发接口)，通过start（）启动CacheDispatcher和NetworkDispatcher;\r\n 4) CacheDisPatcher：缓存线程调度，启动后不断从缓存请求队列中取请求处理，队列为空则等待，处理结束则传递给ResponseDelivery处理\r\n 5) ResponseDelivery：返回结果分发接口\r\n 6）HttpStack：处理Http的请求，返回请求结果，基于HttpURLConnection的HurlStack和基于Apache HttpClient的HttpClientStack\r\n 7）Network:调用HttpStack处理请求，并将结果转换为能被ResponseDeliver处理的NetworkResponse\r\n\r\n3.流程\r\n\r\n\t       主线程                          缓存调度线程                   (丢失)       \t网络调度线程\r\n\t将请求加入缓存列表----------------->缓存调度线程从缓存队列中读取一个请求------->网络调度线程从网络队列中取出一个请求\r\n\t\t\t\t\t\t\t|\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t|（命中）\r\n\t\t\t\t\t\t\t|\r\n\t将解析后的响应传递到主线程<-----------从缓存中读取响应并解析                      Http请求传输、解析、写缓存\r\n                |                                                                           |\r\n                |                                                                           |\r\n               \t<---------------------------------------------------------------------------|\r\n\r\n4.功能\r\n 4.1 volley.java\r\n \t工具类，构建一个RequestQueue对象\r\n \t4.1.1 主要函数\r\n \tpublic static RequestQueue newRequestQueue(Context context)\r\n \tpublic static RequestQueue newRequestQueue(Context context, HttpStack stack)\r\n\r\n \t第一个构造函数调用了第二个构造函数，如果API Level>=9 则采用基于HttpURLConnection的HurlStack，若小于9，则采用基于HttpClient的HttpClient的HttpClientStack\r\n \t随后，构造一个利用stack构造出一个网络的具体实现，并和Cache共同构建一个RequestQueue，并start。\r\n4.2 Request.java\r\n \t网络请求的抽象类，子类有StringRequest JsonRequest ImageRequest，并将他们加入到RequestQueue中来完成一次网络请求操作\r\n \t8种http请求方式，GET POST PUT DELETE HEAD OPTIONS TRACE PATCH\r\n \tRequest类中包含了请求url，请求方式，请求Header，请求Body，请求优先级等信息\r\n \t子类需要重写两个方法 parseNetworkResponse 网络数据返回的字节内容转化为特定的类型\r\n \t\t\t\t\t\tdeliverResponse 将转化后的内容传给监听回调\r\n \tgetBody（）构建用于POST PUT PATCH请求方式的Body内容\r\n \tgetParams 在getBody没有被重写的情况下，返回值会被以key value 的方式编码后转化为字节码作为Body内容\r\n 4.3 RequestQueue.java\r\n \t4.3.1RequestQueue中有两个基于优先级的Request队列，缓存请求队列和网络请求队列\r\n \t放在缓存请求队列中的Request，将通过缓存获得数据，放在网络请求队列中的Request，通过网络获取数据\r\n \tprivate final PriorityBlockingQueue<Request<?>> mCacheQueue = new PriorityBlockingQueue<Request<?>>();\r\n\tprivate final PriorityBlockingQueue<Request<?>> mNetworkQueue = new PriorityBlockingQueue<Request<?>>();\r\n\t一个正在进行中，尚未完成的请求集合\r\n\tprivate final Set<Request<?>> mCurrentRequests = new HashSet<Request<?>>();\r\n\t一个等待请求的集合\r\n\tprivate final Map<String, Queue<Request<?>>> mWaitingRequests = new HashMap<String, Queue<Request<?>>>();\r\n\t4.3.2 启动\r\n\t创建出RequestQueue后，调用start方法，启动Queue。\r\n\tstart方法中，开启了一个缓存调度线程和4个网络调度线程，缓存调度线程从缓存请求队列中取出Request处理，网络调度线程从网络请求队列中取出Request处理\r\n\t4.3.3 加入队列\r\n\r\n\r\n\t开始-->请求到来-->添加到当前队列中mCurrentRequests中-->为请求添加唯一的序列号-->请求是否允许被缓存-->(N)添加到网络请求队列中\r\n\t\t\t\t\t\t\t\t\t\t\t|\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (Y)是否存在相同的请求正在被处理-->（N）创建新的等待当前请求的空队列，添加到缓存队列\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t（Y）加入到相同请求的等待队列中\r\n\t4.3.4 请求完成\r\n\t\t1.先从正在请求的队列中移除该请求\r\n\t\t2.查找在等待请求集合中是否存在等待的请求，如果有则删除，将等待队列移除，并将所有请求添加到缓存请求队列中，并让缓存请求处理线程自动处理\r\n\r\n\t4.3.5 请求取消\r\n\t\t1.cancel All（RequestFilter rf）\r\n\t\t2.cancel All (final Object o)\r\n\t\t\t第一个函数按照过滤器取消请求，第二个函数按照tag取消","google":"    ","note":"Don't delete this file! It's used internally to help with page regeneration."}